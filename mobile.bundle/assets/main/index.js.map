{"version":3,"sources":["assets/Script/Test2.ts","assets/Script/Test3.ts","assets/Script/Test.ts"],"names":["_a","cc","_decorator","ccclass","property","AudioManager","_super","_this","apply","this","arguments","playButton","audioClip","isAudioSystemReset","playingAudios","Map","_testAudioId","__extends","prototype","onLoad","sys","isBrowser","os","OS_IOS","game","on","EVENT_GAME_INITED","EVENT_SHOW","handleGameShow","EVENT_HIDE","handleGameHide","node","onPlayButtonClick","console","log","state","audioEngine","getState","audio","_id2audio","content","__audioSupport","context","scheduleOnce","resume","_sourceNode","disconnect","newSource_1","createBufferSource","_element","_buffer","buffer","_gainObj","connect","loop","_loop","then","currentTime","getCurrentTime","start","catch","e","error","rebuildAudioSystem","oldContext","close","window","AudioContext","playAudio","audioId_1","playEffect","setFinishCallback","duration","getDuration","AudioState","PLAYING","warn","onResume","_context","onReplay","id","setCurrentTime","onDestroy","off","__decorate","Button","AudioClip","Component","exports","default","BgClip","tipAudioUI","Array","isMobile","content_1","savePlayingAudios","_showTipAudioUI","setTimeout","_bgAudioId","state1","length","allAudioIds","Object","keys","_i","allAudioIds_1","idStr","parseInt","push","clip","_src","volume","_volume","finishCallback","_finishCallback","_b","audioInfo","restorePausedAudios","newId","play","Promise","resolve","reject","audioSupport_1","WEB_AUDIO","webkitAudioContext","mozAudioContext","DELAY_CREATE_CTX","audioId","onPlayBgButtonClick","canvas","director","getScene","getChildByName","instantiate","parent","setPosition","Node","EventType","TOUCH_START","destroy","Prefab","NewClass","_resumeAttempts","_maxResumeAttempts","_resumeTimer","addEventListener","onPageShow","bind","onGameShow","onGameHide","event","persisted","clearResumeTimer","scheduleResumeAttempts","clearTimeout","removeEventListener","globalContext","doPlay","err","forceResumeAudioContext","setVolume","setEffectsVolume","resumePlayingAudio","testOsc_1","createOscillator","testGain_1","createGain","gain","value","destination","stop","audioIds","audioIds_1","audioState","_state","paused","_currentSource","getVolume"],"mappings":"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","sourcesContent":["const { ccclass, property } = cc._decorator;\n@ccclass\nexport default class AudioManager extends cc.Component {\n\n    @property(cc.Button)\n    playButton: cc.Button = null;\n\n    @property(cc.AudioClip)\n    audioClip: cc.AudioClip = null;\n\n    private isAudioSystemReset: boolean = true;\n\n    // 保存后台前正在播放的音频信息\n    private playingAudios: Map<number, {\n        clip: cc.AudioClip,\n        loop: boolean,\n        volume: number,\n        currentTime: number\n    }> = new Map();\n\n    onLoad() {\n        if (cc.sys.isBrowser && cc.sys.os === cc.sys.OS_IOS) {\n            cc.game.on(cc.game.EVENT_GAME_INITED, () => {\n                cc.game.on(cc.game.EVENT_SHOW, this.handleGameShow, this);\n                cc.game.on(cc.game.EVENT_HIDE, this.handleGameHide, this);\n            });\n        }\n\n        // 设置按钮事件\n        if (this.playButton) {\n            this.playButton.node.on('click', this.onPlayButtonClick, this);\n        }\n    }\n\n    handleGameShow() {\n        console.log(\"应用恢复到前台\");\n\n        const state = cc.audioEngine.getState(this._testAudioId);\n        console.log(`当前测试音频ID=${this._testAudioId}, 状态=${state}`);\n        const audio = cc.audioEngine._id2audio[this._testAudioId];\n        const content = cc.sys.__audioSupport.context;\n        console.log(`show 当前AudioContext状态:`, content.state);\n        console.log(`当前测试音频信息:`, audio);\n\n        // return;\n\n        // 标记音频系统需要重置\n        this.isAudioSystemReset = false;\n        this.scheduleOnce(() => {\n            content.resume();\n            // this.rebuildAudioSystem();\n\n            // this.scheduleOnce(() => {\n            //     const id = cc.audioEngine.playEffect(this.audioClip, false);\n            //     cc.audioEngine.setCurrentTime(id, 2);\n            //     cc.audioEngine.setFinishCallback(id, () => {\n            //         console.log(\"音频重新播放完成，ID:\", id);\n            //     });\n            // }, 0.4)\n\n             // 核心修复逻辑\n             if (content.state === \"suspended\") {\n                console.log(\"尝试恢复 suspended 状态\");\n\n                // 1. 强制断开音频节点连接（防止残留状态）\n                if (audio?._sourceNode) {\n                    audio._sourceNode.disconnect();\n                    console.log(\"已断开旧音频节点连接\");\n                }\n\n                // 2. 重新创建音频源（关键步骤）\n                const newSource = content.createBufferSource();\n                console.log(\"创建新的音频源节点 newSource: \", newSource);\n                console.log(\"设置音频源 buffer: \", audio._element._buffer);\n                newSource.buffer = audio._element._buffer;\n                console.log(\"设置音频源 _gainObj: \", audio._element._gainObj);\n                newSource.connect(audio._element._gainObj);\n                newSource.loop = audio._element._loop;\n                audio._sourceNode = newSource;\n\n                // 3. 恢复上下文并重启播放\n                content.resume().then(() => {\n                    console.log(\"AudioContext resumed，尝试重新播放\");\n                    // 4. 从上次位置开始播放\n                    const currentTime = cc.audioEngine.getCurrentTime(this._testAudioId);\n                    newSource.start(0, currentTime);\n                }).catch(e => {\n                    console.error(\"恢复失败:\", e);\n                });\n\n            } else {\n                // 正常恢复流程\n                content.resume();\n            }\n        }, 0.1);\n    }\n\n    handleGameHide() {\n        console.log(\"应用进入后台\");\n        const state = cc.audioEngine.getState(this._testAudioId);\n        console.log(`当前测试音频ID=${this._testAudioId}, 状态=${state}`);\n\n        // this.savePlayingAudios();\n\n\n    }\n\n    // // 保存正在播放的音频状态\n    // savePlayingAudios() {\n    //     // 清空旧的记录\n    //     this.playingAudios.clear();\n\n    //     // 获取所有音频ID\n    //     //@ts-ignore\n    //     const allAudioIds = Object.keys(cc.audioEngine._id2audio);\n    //     console.log(`检查 ${allAudioIds.length} 个音频状态`);\n\n    //     for (const idStr of allAudioIds) {\n    //         const id = parseInt(idStr);\n    //         try {\n    //             // 检查是否在播放\n    //             const state = cc.audioEngine.getState(id);\n    //             console.log(`音频ID=${id}, 状态=${state}`);\n    //             if (state === cc.audioEngine.AudioState.PLAYING) {\n    //                 //@ts-ignore\n    //                 const audio = cc.audioEngine._id2audio[id];\n    //                 if (!audio) continue;\n\n    //                 // 获取音频信息\n    //                 const currentTime = cc.audioEngine.getCurrentTime(id);\n    //                 const volume = cc.audioEngine.getVolume(id);\n    //                 const loop = cc.audioEngine.isLoop(id);\n    //                 const clip = audio._src;\n\n    //                 // 保存信息\n    //                 this.playingAudios.set(id, {\n    //                     clip,\n    //                     loop,\n    //                     volume,\n    //                     currentTime\n    //                 });\n\n    //                 console.log(`保存音频状态: ID=${id}, 时间=${currentTime.toFixed(2)}, 循环=${loop}`);\n    //             }\n    //         } catch (e) {\n    //             console.error(`获取音频 ${id} 状态失败:`, e);\n    //         }\n    //     }\n\n    //     console.log(`共保存了 ${this.playingAudios.size} 个正在播放的音频状态`);\n    // }\n\n    // // 恢复之前播放的音频\n    // restorePausedAudios() {\n    //     if (this.playingAudios.size === 0) {\n    //         console.log(\"没有需要恢复的音频\");\n    //         return;\n    //     }\n\n    //     console.log(`准备恢复 ${this.playingAudios.size} 个音频`);\n\n    //     // 逐个恢复\n    //     const newAudioIds = new Map();\n    //     //@ts-ignore\n    //     for (const [oldId, info] of this.playingAudios.entries()) {\n    //         try {\n    //             if (!info.clip) {\n    //                 console.log(`音频 ${oldId} 没有可用的clip，跳过`);\n    //                 continue;\n    //             }\n\n    //             console.log(`恢复音频: 原ID=${oldId}, 时间=${info.currentTime.toFixed(2)}`);\n\n    //             // 重新播放\n    //             const newId = cc.audioEngine.playEffect(info.clip, info.loop);\n    //             cc.audioEngine.setVolume(newId, info.volume);\n\n    //             // 记录新旧ID映射\n    //             newAudioIds.set(oldId, newId);\n\n    //             // 设置播放位置\n    //             if (info.currentTime > 0) {\n    //                 setTimeout(() => {\n    //                     try {\n    //                         cc.audioEngine.setCurrentTime(newId, info.currentTime);\n    //                         console.log(`设置音频 ${newId} 的播放位置: ${info.currentTime.toFixed(2)}`);\n    //                     } catch (e) {\n    //                         console.error(`设置音频 ${newId} 播放位置失败:`, e);\n    //                     }\n    //                 }, 100);\n    //             }\n    //         } catch (e) {\n    //             console.error(`恢复音频 ${oldId} 失败:`, e);\n    //         }\n    //     }\n\n    //     console.log(`成功恢复了 ${newAudioIds.size} 个音频`);\n\n    //     // 清空保存的状态\n    //     this.playingAudios.clear();\n    // }\n\n    rebuildAudioSystem() {\n        console.log(\"开始重建音频系统\");\n\n        try {\n            // 1. 获取当前 AudioContext\n            //@ts-ignore\n            const oldContext = cc.sys.__audioSupport.context;\n\n            if (oldContext) {\n                console.log(\"当前 AudioContext 状态:\", oldContext.state);\n\n                // 2. 关闭旧的 AudioContext\n                try {\n                    if (oldContext.close) {\n                        oldContext.close();\n                        console.log(\"已关闭旧 AudioContext\");\n                    }\n                } catch (e) {\n                    console.error(\"关闭旧 AudioContext 失败:\", e);\n                }\n            }\n\n            // 3. 创建新的 AudioContext\n            console.log(\"创建新的 AudioContext\");\n            const AudioContextClass = window.AudioContext;\n            if (AudioContextClass) {\n                //@ts-ignore\n                cc.sys.__audioSupport.context = new AudioContext();\n                //@ts-ignore\n                console.log(\"新 AudioContext 创建成功，状态:\", cc.sys.__audioSupport.context.state);\n\n                // 标记系统已重置\n                this.isAudioSystemReset = true;\n\n                console.log(\"音频系统重建完成，下次播放应该正常\");\n            }\n        } catch (e) {\n            console.error(\"重建音频系统失败:\", e);\n        }\n    }\n\n    onPlayButtonClick() {\n        console.log(\"播放按钮点击\");\n\n        // 检查音频系统是否需要重置\n        this.playAudio();\n    }\n    private _testAudioId = -1;\n    playAudio() {\n        try {\n            const audioId = cc.audioEngine.playEffect(this.audioClip, false);\n            console.log(\"音频开始播放，ID:\", audioId);\n\n            if (audioId) {\n                cc.audioEngine.setFinishCallback(audioId, () => {\n                    console.log(\"音频播放完成，ID:\", audioId);\n                    this._testAudioId = -1;\n                });\n                const duration = cc.audioEngine.getDuration(audioId);\n                console.log(`音频ID=${audioId}，时长=${duration}`);\n                this._testAudioId = audioId;\n                // 设置检查播放状态的定时器\n                this.scheduleOnce(() => {\n                    try {\n                        const state = cc.audioEngine.getState(audioId);\n                        console.log(`音频${audioId}状态:`, state);\n\n                        if (state !== cc.audioEngine.AudioState.PLAYING) {\n                            console.warn(\"音频可能没有正常播放\");\n                        }\n                    } catch (e) {\n                        console.error(\"检查音频状态失败:\", e);\n                    }\n                }, 0.2);\n            } else {\n                console.error(\"音频播放失败，无效的audioId\");\n            }\n        } catch (e) {\n            console.error(\"播放音频出错:\", e);\n\n            // 如果播放失败，尝试完全重建系统\n            if (cc.sys.os === cc.sys.OS_IOS) {\n                console.log(\"播放失败，尝试重建系统\");\n                this.rebuildAudioSystem();\n            }\n        }\n    }\n\n    onResume() {\n        console.log(\"手动恢复按钮点击\");\n        // this.rebuildAudioSystem();\n\n        const context = cc.sys.__audioSupport.context;\n        const audio = cc.audioEngine._id2audio[this._testAudioId];\n        if (context == audio._element._context) {\n            console.log(\"当前音频上下文与全局一致，尝试恢复\");\n        }\n        console.log(\"当前AudioContext状态:\", context.state);\n        if (audio._element._context.state === \"interrupted\") {\n\n            console.log(\"音频系统中断，尝试恢复\");\n            audio._element._context.resume();\n        }\n        context.resume();\n\n\n    }\n\n    onReplay() {\n\n\n        const id = cc.audioEngine.playEffect(this.audioClip, false);\n        const onFinish = () => {\n            console.log(\"音频播放完成，ID:\", id);\n        }\n        cc.audioEngine.setFinishCallback(id, onFinish);\n        cc.audioEngine.setCurrentTime(id, 2);\n        // cc.audioEngine.setFinishCallback(id, onFinish);\n\n\n        // this.scheduleOnce(() => {\n        //     cc.audioEngine.setFinishCallback(id, () => {\n        //         console.log(\"音频重新播放完成，ID:\", id);\n        //         this._testAudioId = -1;\n        //     });\n        // }, 0.2)\n    }\n\n    onDestroy() {\n        cc.game.off(cc.game.EVENT_SHOW, this.handleGameShow, this);\n        cc.game.off(cc.game.EVENT_HIDE, this.handleGameHide, this);\n    }\n}","/**\n * 这个文件是最终版本\n * 主要是为了测试音频恢复功能最终确认是否正常工作\n * \n */\n\nconst { ccclass, property } = cc._decorator;\n@ccclass\nexport default class AudioManager extends cc.Component {\n\n    @property(cc.Button)\n    playButton: cc.Button = null;\n\n    @property(cc.AudioClip)\n    audioClip: cc.AudioClip = null;\n @property(cc.AudioClip)\n    BgClip: cc.AudioClip = null;\n    @property(cc.Prefab)\n    tipAudioUI: cc.Prefab = null;\n\n    private _testAudioId: number = -1;\n    private _bgAudioId;\n    // 保存正在播放的音频信息\n    private playingAudios: Array<{\n        id: number,\n        clip: cc.AudioClip,\n        loop: boolean,\n        volume: number,\n        currentTime: number,\n        finishCallback?: (audioId: number) => void\n    }> = new Array();\n\n    onLoad() {\n        if (cc.sys.isBrowser && cc.sys.os === cc.sys.OS_IOS) {\n            cc.game.on(cc.game.EVENT_GAME_INITED, () => {\n                cc.game.on(cc.game.EVENT_SHOW, this.handleGameShow, this);\n                cc.game.on(cc.game.EVENT_HIDE, this.handleGameHide, this);\n            });\n        }\n    }\n\n    handleGameShow() {\n        console.log(\"应用恢复到前台\");\n\n        if (cc.sys.os === cc.sys.OS_IOS && cc.sys.isBrowser && cc.sys.isMobile) {\n            //@ts-ignore\n            const content = cc.sys.__audioSupport.context;\n            console.log(`当前音频上下文状态: ${content.state}`);\n            if (content.state === \"suspended\") {\n                //挂起状态，高版本ios系统, 需要重建 audioContent, 启用并关闭旧的\n                this.savePlayingAudios();\n                this.rebuildAudioSystem().then(() => {\n                    //展示恢复音频界面，提示用户触摸屏幕恢复音频播放\n                    this._showTipAudioUI();\n                });\n            }\n            else if (content.state === \"interrupted\") {\n                // 需要延迟一小会儿, 给系统初始化时间\n                console.log(\"普通恢复\");\n                setTimeout(() => {\n                    content.resume();\n                },  50);\n                \n            }\n        }\n    }\n\n    handleGameHide() {\n        console.log(\"应用进入后台\");\n        if(this._testAudioId != -1) {\n            const state = cc.audioEngine.getState(this._testAudioId);\n            console.log(`当前测试音频ID=${this._testAudioId}, 状态=${state}`);\n        }\n         if(this._bgAudioId != -1) {\n            const state1 = cc.audioEngine.getState(this._bgAudioId);\n            console.log(`当前测试音频ID=${this._bgAudioId}, 状态=${state1}`);\n        }\n    }\n\n    savePlayingAudios() {\n        this.playingAudios.length = 0; // 清空旧的记录\n        //@ts-ignore\n        const allAudioIds = Object.keys(cc.audioEngine._id2audio);\n        console.log(`检查 ${allAudioIds.length} 个音频状态`);\n\n        for (const idStr of allAudioIds) {\n            const id = parseInt(idStr);\n            const state = cc.audioEngine.getState(id);\n            if (state === cc.audioEngine.AudioState.PLAYING) {\n                //@ts-ignore\n                const audio = cc.audioEngine._id2audio[id];\n                // 获取音频信息\n                this.playingAudios.push({\n                    id: id,\n                    clip: audio._src,\n                    loop: audio._element._loop,\n                    volume: audio._element._volume,\n                    currentTime: audio._element.currentTime,\n                    finishCallback: audio._finishCallback\n                });\n            }\n        }\n        for (const audioInfo of this.playingAudios) {\n            console.log(`保存音频状态: ID=${audioInfo.id}, 时间=${audioInfo.currentTime}, 循环=${audioInfo.loop}, 音量=${audioInfo.volume}, 回调=${audioInfo.finishCallback ? '有' : '无'}`);\n        }\n    }\n\n    // 恢复之前播放的音频\n    restorePausedAudios() {\n        if (this.playingAudios.length === 0) {\n            console.log(\"没有需要恢复的音频\");\n            return;\n        }\n\n        console.log(`准备恢复 ${this.playingAudios.length} 个音频`);\n\n        for (const audioInfo of this.playingAudios) {\n            console.log(`恢复音频状态: ID=${audioInfo.id}, 时间=${audioInfo.currentTime}, 循环=${audioInfo.loop}, 音量=${audioInfo.volume}, 回调=${audioInfo.finishCallback ? '有' : '无'}`);\n            if (!audioInfo.clip) {\n                console.log(`音频没有可用的clip, 跳过`);\n                continue;\n            }\n            // 重新播放\n            const newId = cc.audioEngine.play(audioInfo.clip, audioInfo.loop, audioInfo.volume);\n            if (audioInfo.currentTime > 0) {\n                cc.audioEngine.setCurrentTime(newId, audioInfo.currentTime);\n            }\n            if (audioInfo.finishCallback) {\n                cc.audioEngine.setFinishCallback(newId, audioInfo.finishCallback);\n            }\n        }\n        \n        this.playingAudios.length = 0;\n    }\n\n    async rebuildAudioSystem() {\n        console.log(\"开始重建音频系统\");\n        return new Promise((resolve, reject) => {\n            // 需要延迟一下\n            setTimeout(() => {\n                try {\n                    //@ts-ignore\n                    const oldContext = cc.sys.__audioSupport.context;\n                    if (oldContext && oldContext.close) {\n                        oldContext.close();\n                        console.log(\"已关闭旧 AudioContext\");\n                    }\n                    // 3. 创建新的 AudioContext\n                    console.log(\"创建新的 AudioContext\");\n                    const AudioContextClass = window.AudioContext;\n                    if (AudioContextClass) {\n                        //@ts-ignore\n                        const audioSupport = cc.sys.__audioSupport;\n                        //以下摘自引擎源码的创建方式\n                        if (audioSupport.WEB_AUDIO) {\n                            //@ts-ignore\n                            audioSupport.context = new (window.AudioContext || window.webkitAudioContext || window.mozAudioContext)();\n                            if (audioSupport.DELAY_CREATE_CTX) {\n                                //@ts-ignore\n                                setTimeout(function () { audioSupport.context = new (window.AudioContext || window.webkitAudioContext || window.mozAudioContext)(); }, 0);\n                            }\n                        }\n                        //@ts-ignore\n                        console.log(\"新 AudioContext 创建成功，状态:\", cc.sys.__audioSupport.context.state);\n                    }\n                    resolve(true);\n                } catch (e) {\n                    console.error(\"重建音频系统失败:\", e);\n                    reject(e);\n                }\n            }, 50);\n        });\n    }\n\n    onPlayButtonClick() {\n        console.log(\"播放按钮点击\");\n\n        const audioId = cc.audioEngine.playEffect(this.audioClip, false);\n        cc.audioEngine.setFinishCallback(audioId, () => {\n            console.log(\"音频播放完成，ID:\", audioId);\n        });\n    }\n    onPlayBgButtonClick() {\n        console.log(\"播放背景音乐按钮点击\");\n\n        this._bgAudioId = cc.audioEngine.play(this.BgClip, true, 1);\n        cc.audioEngine.setFinishCallback(this._bgAudioId, () => {\n            console.log(\"背景音乐播放完成，ID:\", this._bgAudioId);\n        });\n    }\n    \n    private _showTipAudioUI() {\n        const scene = cc.director.getScene();\n        const canvas = scene.getChildByName(\"Canvas\");\n        let tipAudioUI = cc.instantiate(this.tipAudioUI);\n        tipAudioUI.parent = canvas;\n        tipAudioUI.setPosition(0, 0);\n        tipAudioUI.on(cc.Node.EventType.TOUCH_START, () => {\n            this.restorePausedAudios();\n            tipAudioUI.destroy();\n        });\n    }\n\n    onResume() {\n        console.log(\"手动恢复按钮点击\");\n        // this.rebuildAudioSystem();\n\n        this.restorePausedAudios();\n    }\n\n    onReplay() {\n        const id = cc.audioEngine.playEffect(this.audioClip, false);\n        const onFinish = () => {\n            console.log(\"音频播放完成，ID:\", id);\n        }\n        cc.audioEngine.setFinishCallback(id, onFinish);\n        cc.audioEngine.setCurrentTime(id, 2);\n    }\n\n    onDestroy() {\n        cc.game.off(cc.game.EVENT_SHOW, this.handleGameShow, this);\n        cc.game.off(cc.game.EVENT_HIDE, this.handleGameHide, this);\n    }\n}","\nconst { ccclass, property } = cc._decorator;\n\n@ccclass\nexport default class NewClass extends cc.Component {\n\n    private _resumeAttempts = 0;\n    private _maxResumeAttempts = 3;\n    private _resumeTimer = null;\n\n    onLoad() {\n        // 使用捕获阶段监听pageshow事件，确保尽早处理\n        window.addEventListener('pageshow', this.onPageShow.bind(this), true);\n        \n        // 使用自定义的展示事件处理函数\n        cc.game.on(cc.game.EVENT_SHOW, this.onGameShow.bind(this));\n        cc.game.on(cc.game.EVENT_HIDE, this.onGameHide.bind(this));\n    }\n\n    onPageShow(event) {\n        console.log(\"pageshow事件触发\", event.persisted);\n        if (event.persisted && cc.sys.os === cc.sys.OS_IOS) {\n            // 清除之前可能存在的定时器\n            this.clearResumeTimer();\n            \n            // 重置恢复尝试次数\n            this._resumeAttempts = 0;\n            \n            // 立即尝试一次恢复\n            this.onResume();\n            \n            // 设置多次尝试恢复的定时器\n            this.scheduleResumeAttempts();\n        }\n    }\n\n    onGameShow() {\n        console.log(\"Game.EVENT_SHOW\");\n        if (cc.sys.os === cc.sys.OS_IOS) {\n            // 清除之前可能存在的定时器\n            this.clearResumeTimer();\n            \n            // 重置恢复尝试次数\n            this._resumeAttempts = 0;\n            \n            // 立即尝试一次恢复\n            this.onResume();\n            \n            // 设置多次尝试恢复的定时器\n            this.scheduleResumeAttempts();\n        }\n    }\n\n    onGameHide() {\n        console.log(\"Game.EVENT_HIDE\");\n        // 清除恢复定时器\n        this.clearResumeTimer();\n    }\n\n    scheduleResumeAttempts() {\n        // 设置多次尝试，间隔递增\n        this._resumeTimer = setTimeout(() => {\n            this._resumeAttempts++;\n            if (this._resumeAttempts < this._maxResumeAttempts) {\n                console.log(`第${this._resumeAttempts}次尝试恢复AudioContext`);\n                this.onResume();\n                this.scheduleResumeAttempts();\n            }\n        }, 300 * (this._resumeAttempts + 1)); // 300ms, 600ms, 900ms递增间隔\n    }\n\n    clearResumeTimer() {\n        if (this._resumeTimer) {\n            clearTimeout(this._resumeTimer);\n            this._resumeTimer = null;\n        }\n    }\n\n    @property(cc.AudioClip)\n    audioClip: cc.AudioClip = null;\n\n    start() {}\n\n    onDestroy() {\n        // 清除定时器\n        this.clearResumeTimer();\n        \n        // 移除事件监听\n        window.removeEventListener('pageshow', this.onPageShow.bind(this), true);\n        cc.game.off(cc.game.EVENT_SHOW, this.onGameShow, this);\n        cc.game.off(cc.game.EVENT_HIDE, this.onGameHide, this);\n    }\n\n    play() {\n        // 在播放前检查AudioContext状态\n        if (cc.sys.os === cc.sys.OS_IOS) {\n            const globalContext = cc.sys.__audioSupport.context;\n            if (globalContext && \n                (globalContext.state === 'suspended' || globalContext.state === 'interrupted')) {\n                \n                console.log(\"播放前恢复AudioContext\");\n                globalContext.resume().then(() => {\n                    this.doPlay();\n                }).catch(err => {\n                    console.error(\"播放前恢复AudioContext失败:\", err);\n                    // 尝试强制恢复\n                    this.forceResumeAudioContext();\n                    setTimeout(() => this.doPlay(), 100);\n                });\n            } else {\n                this.doPlay();\n            }\n        } else {\n            this.doPlay();\n        }\n    }\n\n    doPlay() {\n        const audioId = cc.audioEngine.playEffect(this.audioClip, false);\n        console.log(\"audioId play:\", audioId);\n        if (audioId) {\n            cc.audioEngine.setVolume(audioId, 1);\n            cc.audioEngine.setEffectsVolume(1);\n            cc.audioEngine.setFinishCallback(audioId, () => {\n                console.log(\"audio play finish\");\n            });\n        } else {\n            console.error(\"音频播放失败，无效的audioId\");\n        }\n    }\n\n    onResume() {\n        const globalContext = cc.sys.__audioSupport.context;\n        if (!globalContext) {\n            console.warn(\"找不到全局AudioContext\");\n            return;\n        }\n        \n        console.log(\"当前AudioContext状态:\", globalContext.state);\n        \n        if (globalContext.state === 'suspended' || globalContext.state === 'interrupted') {\n            console.log(\"恢复全局AudioContext\");\n            \n            // 尝试恢复全局AudioContext\n            globalContext.resume().then(() => {\n                console.log(\"全局AudioContext恢复成功\");\n                \n                // 强制\"唤醒\"音频系统\n                this.forceResumeAudioContext();\n                \n                // 恢复正在播放的音频\n                this.resumePlayingAudio();\n            }).catch(err => {\n                console.error(\"恢复AudioContext失败:\", err);\n                \n                // 尝试使用更激进的方式恢复\n                this.forceResumeAudioContext();\n            });\n        } else {\n            console.log(\"AudioContext状态已正常:\", globalContext.state);\n            \n            // 即使状态看起来正常，也进行一次音频恢复\n            // 有时iOS会报告状态正常但实际上还是无法播放\n            this.resumePlayingAudio();\n        }\n    }\n    \n    forceResumeAudioContext() {\n        try {\n            const globalContext = cc.sys.__audioSupport.context;\n            if (!globalContext) return;\n            \n            // 创建一个短暂的空音频来\"唤醒\"系统\n            const testOsc = globalContext.createOscillator();\n            const testGain = globalContext.createGain();\n            testGain.gain.value = 0.01; // 极小音量但不是0\n            testOsc.connect(testGain);\n            testGain.connect(globalContext.destination);\n            testOsc.start(0);\n            setTimeout(() => {\n                try {\n                    testOsc.stop();\n                    testOsc.disconnect();\n                    testGain.disconnect();\n                } catch (e) {}\n            }, 100); // 短暂播放100ms\n            \n            console.log(\"强制唤醒AudioContext完成\");\n        } catch (e) {\n            console.error(\"强制唤醒AudioContext失败:\", e);\n        }\n    }\n    \n    resumePlayingAudio() {\n        // 遍历所有音频并检查它们的状态\n        const audioIds = Object.keys(cc.audioEngine._id2audio);\n        console.log(\"恢复音频状态检查, 当前音频数:\", audioIds.length);\n        \n        if (audioIds.length === 0) return;\n        \n        // 恢复所有正在播放的音频\n        for (let id of audioIds) {\n            const audio = cc.audioEngine._id2audio[id];\n            if (!audio || !audio._element) continue;\n            \n            const audioState = audio._state;\n            console.log(`音频ID: ${id}, 状态: ${audioState}`);\n            \n            if (audioState === cc.audioEngine.AudioState.PLAYING && \n                (audio._element.paused || \n                (audio._element._currentSource === null && audio._element._context))) {\n                console.log(`恢复播放音频: ${id}`);\n                \n                try {\n                    // 先确保音量正确\n                    const volume = audio.getVolume();\n                    audio.setVolume(volume);\n                    \n                    // 然后恢复播放\n                    audio.resume();\n                } catch (e) {\n                    console.error(`恢复音频${id}失败:`, e);\n                }\n            }\n        }\n    }\n}"],"file":"index.js"}