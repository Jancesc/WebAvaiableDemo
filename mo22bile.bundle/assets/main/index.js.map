{"version":3,"sources":["assets/Script/Test2.ts","assets/Script/Test3.ts","assets/Script/Test.ts"],"names":["_a","cc","_decorator","ccclass","property","AudioManager","_super","_this","apply","this","arguments","playButton","audioClip","isAudioSystemReset","playingAudios","Map","_testAudioId","__extends","prototype","onLoad","sys","isBrowser","os","OS_IOS","game","on","EVENT_GAME_INITED","EVENT_SHOW","handleGameShow","EVENT_HIDE","handleGameHide","node","onPlayButtonClick","console","log","state","audioEngine","getState","audio","_id2audio","content","__audioSupport","context","scheduleOnce","resume","_sourceNode","disconnect","newSource_1","createBufferSource","_element","_buffer","buffer","_gainObj","connect","loop","_loop","then","currentTime","getCurrentTime","start","catch","e","error","rebuildAudioSystem","oldContext","close","window","AudioContext","playAudio","audioId_1","playEffect","setFinishCallback","duration","getDuration","AudioState","PLAYING","warn","onResume","_context","onReplay","id","setCurrentTime","onDestroy","off","__decorate","Button","AudioClip","Component","exports","default","tipAudioUI","Array","isMobile","content_1","savePlayingAudios","_showTipAudioUI","setTimeout","length","allAudioIds","Object","keys","_i","allAudioIds_1","idStr","parseInt","push","clip","_src","volume","_volume","finishCallback","_finishCallback","_b","audioInfo","restorePausedAudios","newId","play","Promise","resolve","reject","audioSupport_1","WEB_AUDIO","webkitAudioContext","mozAudioContext","DELAY_CREATE_CTX","audioId","canvas","director","getScene","getChildByName","instantiate","parent","setPosition","Node","EventType","TOUCH_START","destroy","Prefab","NewClass","_resumeAttempts","_maxResumeAttempts","_resumeTimer","addEventListener","onPageShow","bind","onGameShow","onGameHide","event","persisted","clearResumeTimer","scheduleResumeAttempts","clearTimeout","removeEventListener","globalContext","doPlay","err","forceResumeAudioContext","setVolume","setEffectsVolume","resumePlayingAudio","testOsc_1","createOscillator","testGain_1","createGain","gain","value","destination","stop","audioIds","audioIds_1","audioState","_state","paused","_currentSource","getVolume"],"mappings":"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","sourcesContent":["const { ccclass, property } = cc._decorator;\n@ccclass\nexport default class AudioManager extends cc.Component {\n\n    @property(cc.Button)\n    playButton: cc.Button = null;\n\n    @property(cc.AudioClip)\n    audioClip: cc.AudioClip = null;\n\n    private isAudioSystemReset: boolean = true;\n\n    // 保存后台前正在播放的音频信息\n    private playingAudios: Map<number, {\n        clip: cc.AudioClip,\n        loop: boolean,\n        volume: number,\n        currentTime: number\n    }> = new Map();\n\n    onLoad() {\n        if (cc.sys.isBrowser && cc.sys.os === cc.sys.OS_IOS) {\n            cc.game.on(cc.game.EVENT_GAME_INITED, () => {\n                cc.game.on(cc.game.EVENT_SHOW, this.handleGameShow, this);\n                cc.game.on(cc.game.EVENT_HIDE, this.handleGameHide, this);\n            });\n        }\n\n        // 设置按钮事件\n        if (this.playButton) {\n            this.playButton.node.on('click', this.onPlayButtonClick, this);\n        }\n    }\n\n    handleGameShow() {\n        console.log(\"应用恢复到前台\");\n\n        const state = cc.audioEngine.getState(this._testAudioId);\n        console.log(`当前测试音频ID=${this._testAudioId}, 状态=${state}`);\n        const audio = cc.audioEngine._id2audio[this._testAudioId];\n        const content = cc.sys.__audioSupport.context;\n        console.log(`show 当前AudioContext状态:`, content.state);\n        console.log(`当前测试音频信息:`, audio);\n\n        // return;\n\n        // 标记音频系统需要重置\n        this.isAudioSystemReset = false;\n        this.scheduleOnce(() => {\n            content.resume();\n            // this.rebuildAudioSystem();\n\n            // this.scheduleOnce(() => {\n            //     const id = cc.audioEngine.playEffect(this.audioClip, false);\n            //     cc.audioEngine.setCurrentTime(id, 2);\n            //     cc.audioEngine.setFinishCallback(id, () => {\n            //         console.log(\"音频重新播放完成，ID:\", id);\n            //     });\n            // }, 0.4)\n\n             // 核心修复逻辑\n             if (content.state === \"suspended\") {\n                console.log(\"尝试恢复 suspended 状态\");\n\n                // 1. 强制断开音频节点连接（防止残留状态）\n                if (audio?._sourceNode) {\n                    audio._sourceNode.disconnect();\n                    console.log(\"已断开旧音频节点连接\");\n                }\n\n                // 2. 重新创建音频源（关键步骤）\n                const newSource = content.createBufferSource();\n                console.log(\"创建新的音频源节点 newSource: \", newSource);\n                console.log(\"设置音频源 buffer: \", audio._element._buffer);\n                newSource.buffer = audio._element._buffer;\n                console.log(\"设置音频源 _gainObj: \", audio._element._gainObj);\n                newSource.connect(audio._element._gainObj);\n                newSource.loop = audio._element._loop;\n                audio._sourceNode = newSource;\n\n                // 3. 恢复上下文并重启播放\n                content.resume().then(() => {\n                    console.log(\"AudioContext resumed，尝试重新播放\");\n                    // 4. 从上次位置开始播放\n                    const currentTime = cc.audioEngine.getCurrentTime(this._testAudioId);\n                    newSource.start(0, currentTime);\n                }).catch(e => {\n                    console.error(\"恢复失败:\", e);\n                });\n\n            } else {\n                // 正常恢复流程\n                content.resume();\n            }\n        }, 0.1);\n    }\n\n    handleGameHide() {\n        console.log(\"应用进入后台\");\n        const state = cc.audioEngine.getState(this._testAudioId);\n        console.log(`当前测试音频ID=${this._testAudioId}, 状态=${state}`);\n\n        // this.savePlayingAudios();\n\n\n    }\n\n    // // 保存正在播放的音频状态\n    // savePlayingAudios() {\n    //     // 清空旧的记录\n    //     this.playingAudios.clear();\n\n    //     // 获取所有音频ID\n    //     //@ts-ignore\n    //     const allAudioIds = Object.keys(cc.audioEngine._id2audio);\n    //     console.log(`检查 ${allAudioIds.length} 个音频状态`);\n\n    //     for (const idStr of allAudioIds) {\n    //         const id = parseInt(idStr);\n    //         try {\n    //             // 检查是否在播放\n    //             const state = cc.audioEngine.getState(id);\n    //             console.log(`音频ID=${id}, 状态=${state}`);\n    //             if (state === cc.audioEngine.AudioState.PLAYING) {\n    //                 //@ts-ignore\n    //                 const audio = cc.audioEngine._id2audio[id];\n    //                 if (!audio) continue;\n\n    //                 // 获取音频信息\n    //                 const currentTime = cc.audioEngine.getCurrentTime(id);\n    //                 const volume = cc.audioEngine.getVolume(id);\n    //                 const loop = cc.audioEngine.isLoop(id);\n    //                 const clip = audio._src;\n\n    //                 // 保存信息\n    //                 this.playingAudios.set(id, {\n    //                     clip,\n    //                     loop,\n    //                     volume,\n    //                     currentTime\n    //                 });\n\n    //                 console.log(`保存音频状态: ID=${id}, 时间=${currentTime.toFixed(2)}, 循环=${loop}`);\n    //             }\n    //         } catch (e) {\n    //             console.error(`获取音频 ${id} 状态失败:`, e);\n    //         }\n    //     }\n\n    //     console.log(`共保存了 ${this.playingAudios.size} 个正在播放的音频状态`);\n    // }\n\n    // // 恢复之前播放的音频\n    // restorePausedAudios() {\n    //     if (this.playingAudios.size === 0) {\n    //         console.log(\"没有需要恢复的音频\");\n    //         return;\n    //     }\n\n    //     console.log(`准备恢复 ${this.playingAudios.size} 个音频`);\n\n    //     // 逐个恢复\n    //     const newAudioIds = new Map();\n    //     //@ts-ignore\n    //     for (const [oldId, info] of this.playingAudios.entries()) {\n    //         try {\n    //             if (!info.clip) {\n    //                 console.log(`音频 ${oldId} 没有可用的clip，跳过`);\n    //                 continue;\n    //             }\n\n    //             console.log(`恢复音频: 原ID=${oldId}, 时间=${info.currentTime.toFixed(2)}`);\n\n    //             // 重新播放\n    //             const newId = cc.audioEngine.playEffect(info.clip, info.loop);\n    //             cc.audioEngine.setVolume(newId, info.volume);\n\n    //             // 记录新旧ID映射\n    //             newAudioIds.set(oldId, newId);\n\n    //             // 设置播放位置\n    //             if (info.currentTime > 0) {\n    //                 setTimeout(() => {\n    //                     try {\n    //                         cc.audioEngine.setCurrentTime(newId, info.currentTime);\n    //                         console.log(`设置音频 ${newId} 的播放位置: ${info.currentTime.toFixed(2)}`);\n    //                     } catch (e) {\n    //                         console.error(`设置音频 ${newId} 播放位置失败:`, e);\n    //                     }\n    //                 }, 100);\n    //             }\n    //         } catch (e) {\n    //             console.error(`恢复音频 ${oldId} 失败:`, e);\n    //         }\n    //     }\n\n    //     console.log(`成功恢复了 ${newAudioIds.size} 个音频`);\n\n    //     // 清空保存的状态\n    //     this.playingAudios.clear();\n    // }\n\n    rebuildAudioSystem() {\n        console.log(\"开始重建音频系统\");\n\n        try {\n            // 1. 获取当前 AudioContext\n            //@ts-ignore\n            const oldContext = cc.sys.__audioSupport.context;\n\n            if (oldContext) {\n                console.log(\"当前 AudioContext 状态:\", oldContext.state);\n\n                // 2. 关闭旧的 AudioContext\n                try {\n                    if (oldContext.close) {\n                        oldContext.close();\n                        console.log(\"已关闭旧 AudioContext\");\n                    }\n                } catch (e) {\n                    console.error(\"关闭旧 AudioContext 失败:\", e);\n                }\n            }\n\n            // 3. 创建新的 AudioContext\n            console.log(\"创建新的 AudioContext\");\n            const AudioContextClass = window.AudioContext;\n            if (AudioContextClass) {\n                //@ts-ignore\n                cc.sys.__audioSupport.context = new AudioContext();\n                //@ts-ignore\n                console.log(\"新 AudioContext 创建成功，状态:\", cc.sys.__audioSupport.context.state);\n\n                // 标记系统已重置\n                this.isAudioSystemReset = true;\n\n                console.log(\"音频系统重建完成，下次播放应该正常\");\n            }\n        } catch (e) {\n            console.error(\"重建音频系统失败:\", e);\n        }\n    }\n\n    onPlayButtonClick() {\n        console.log(\"播放按钮点击\");\n\n        // 检查音频系统是否需要重置\n        this.playAudio();\n    }\n    private _testAudioId = -1;\n    playAudio() {\n        try {\n            const audioId = cc.audioEngine.playEffect(this.audioClip, false);\n            console.log(\"音频开始播放，ID:\", audioId);\n\n            if (audioId) {\n                cc.audioEngine.setFinishCallback(audioId, () => {\n                    console.log(\"音频播放完成，ID:\", audioId);\n                    this._testAudioId = -1;\n                });\n                const duration = cc.audioEngine.getDuration(audioId);\n                console.log(`音频ID=${audioId}，时长=${duration}`);\n                this._testAudioId = audioId;\n                // 设置检查播放状态的定时器\n                this.scheduleOnce(() => {\n                    try {\n                        const state = cc.audioEngine.getState(audioId);\n                        console.log(`音频${audioId}状态:`, state);\n\n                        if (state !== cc.audioEngine.AudioState.PLAYING) {\n                            console.warn(\"音频可能没有正常播放\");\n                        }\n                    } catch (e) {\n                        console.error(\"检查音频状态失败:\", e);\n                    }\n                }, 0.2);\n            } else {\n                console.error(\"音频播放失败，无效的audioId\");\n            }\n        } catch (e) {\n            console.error(\"播放音频出错:\", e);\n\n            // 如果播放失败，尝试完全重建系统\n            if (cc.sys.os === cc.sys.OS_IOS) {\n                console.log(\"播放失败，尝试重建系统\");\n                this.rebuildAudioSystem();\n            }\n        }\n    }\n\n    onResume() {\n        console.log(\"手动恢复按钮点击\");\n        // this.rebuildAudioSystem();\n\n        const context = cc.sys.__audioSupport.context;\n        const audio = cc.audioEngine._id2audio[this._testAudioId];\n        if (context == audio._element._context) {\n            console.log(\"当前音频上下文与全局一致，尝试恢复\");\n        }\n        console.log(\"当前AudioContext状态:\", context.state);\n        if (audio._element._context.state === \"interrupted\") {\n\n            console.log(\"音频系统中断，尝试恢复\");\n            audio._element._context.resume();\n        }\n        context.resume();\n\n\n    }\n\n    onReplay() {\n\n\n        const id = cc.audioEngine.playEffect(this.audioClip, false);\n        const onFinish = () => {\n            console.log(\"音频播放完成，ID:\", id);\n        }\n        cc.audioEngine.setFinishCallback(id, onFinish);\n        cc.audioEngine.setCurrentTime(id, 2);\n        // cc.audioEngine.setFinishCallback(id, onFinish);\n\n\n        // this.scheduleOnce(() => {\n        //     cc.audioEngine.setFinishCallback(id, () => {\n        //         console.log(\"音频重新播放完成，ID:\", id);\n        //         this._testAudioId = -1;\n        //     });\n        // }, 0.2)\n    }\n\n    onDestroy() {\n        cc.game.off(cc.game.EVENT_SHOW, this.handleGameShow, this);\n        cc.game.off(cc.game.EVENT_HIDE, this.handleGameHide, this);\n    }\n}","/**\n * 这个文件是最终版本\n * 主要是为了测试音频恢复功能最终确认是否正常工作\n * \n */\n\nconst { ccclass, property } = cc._decorator;\n@ccclass\nexport default class AudioManager extends cc.Component {\n\n    @property(cc.Button)\n    playButton: cc.Button = null;\n\n    @property(cc.AudioClip)\n    audioClip: cc.AudioClip = null;\n\n    @property(cc.Prefab)\n    tipAudioUI: cc.Prefab = null;\n\n    private _testAudioId: number = -1;\n\n    // 保存正在播放的音频信息\n    private playingAudios: Array<{\n        id: number,\n        clip: cc.AudioClip,\n        loop: boolean,\n        volume: number,\n        currentTime: number,\n        finishCallback?: (audioId: number) => void\n    }> = new Array();\n\n    onLoad() {\n        if (cc.sys.isBrowser && cc.sys.os === cc.sys.OS_IOS) {\n            cc.game.on(cc.game.EVENT_GAME_INITED, () => {\n                cc.game.on(cc.game.EVENT_SHOW, this.handleGameShow, this);\n                cc.game.on(cc.game.EVENT_HIDE, this.handleGameHide, this);\n            });\n        }\n    }\n\n    handleGameShow() {\n        console.log(\"应用恢复到前台\");\n\n        if (cc.sys.os === cc.sys.OS_IOS && cc.sys.isBrowser && cc.sys.isMobile) {\n            //@ts-ignore\n            const content = cc.sys.__audioSupport.context;\n            console.log(`当前音频上下文状态: ${content.state}`);\n            if (content.state === \"suspended\") {\n                //挂起状态，高版本ios系统, 需要重建 audioContent, 启用并关闭旧的\n                this.savePlayingAudios();\n                this.rebuildAudioSystem().then(() => {\n                    //展示恢复音频界面，提示用户触摸屏幕恢复音频播放\n                    this._showTipAudioUI();\n                });\n            }\n            else if (content.state === \"interrupted\") {\n                // 需要延迟一小会儿, 给系统初始化时间\n                console.log(\"普通恢复\");\n                setTimeout(() => {\n                    content.resume();\n                },  50);\n                \n            }\n        }\n    }\n\n    handleGameHide() {\n        console.log(\"应用进入后台\");\n        if(this._testAudioId != -1) {\n            const state = cc.audioEngine.getState(this._testAudioId);\n            console.log(`当前测试音频ID=${this._testAudioId}, 状态=${state}`);\n        }\n    }\n\n    savePlayingAudios() {\n        this.playingAudios.length = 0; // 清空旧的记录\n        //@ts-ignore\n        const allAudioIds = Object.keys(cc.audioEngine._id2audio);\n        console.log(`检查 ${allAudioIds.length} 个音频状态`);\n\n        for (const idStr of allAudioIds) {\n            const id = parseInt(idStr);\n            const state = cc.audioEngine.getState(id);\n            if (state === cc.audioEngine.AudioState.PLAYING) {\n                //@ts-ignore\n                const audio = cc.audioEngine._id2audio[id];\n                // 获取音频信息\n                this.playingAudios.push({\n                    id: id,\n                    clip: audio._src,\n                    loop: audio._element._loop,\n                    volume: audio._element._volume,\n                    currentTime: audio._element.currentTime,\n                    finishCallback: audio._finishCallback\n                });\n            }\n        }\n        for (const audioInfo of this.playingAudios) {\n            console.log(`保存音频状态: ID=${audioInfo.id}, 时间=${audioInfo.currentTime}, 循环=${audioInfo.loop}, 音量=${audioInfo.volume}, 回调=${audioInfo.finishCallback ? '有' : '无'}`);\n        }\n    }\n\n    // 恢复之前播放的音频\n    restorePausedAudios() {\n        if (this.playingAudios.length === 0) {\n            console.log(\"没有需要恢复的音频\");\n            return;\n        }\n\n        console.log(`准备恢复 ${this.playingAudios.length} 个音频`);\n\n        for (const audioInfo of this.playingAudios) {\n            console.log(`恢复音频状态: ID=${audioInfo.id}, 时间=${audioInfo.currentTime}, 循环=${audioInfo.loop}, 音量=${audioInfo.volume}, 回调=${audioInfo.finishCallback ? '有' : '无'}`);\n            if (!audioInfo.clip) {\n                console.log(`音频没有可用的clip, 跳过`);\n                continue;\n            }\n            // 重新播放\n            const newId = cc.audioEngine.play(audioInfo.clip, audioInfo.loop, audioInfo.volume);\n            if (audioInfo.currentTime > 0) {\n                cc.audioEngine.setCurrentTime(newId, audioInfo.currentTime);\n            }\n            if (audioInfo.finishCallback) {\n                cc.audioEngine.setFinishCallback(newId, audioInfo.finishCallback);\n            }\n        }\n        \n        this.playingAudios.length = 0;\n    }\n\n    async rebuildAudioSystem() {\n        console.log(\"开始重建音频系统\");\n        return new Promise((resolve, reject) => {\n            // 需要延迟一下\n            setTimeout(() => {\n                try {\n                    //@ts-ignore\n                    const oldContext = cc.sys.__audioSupport.context;\n                    if (oldContext && oldContext.close) {\n                        oldContext.close();\n                        console.log(\"已关闭旧 AudioContext\");\n                    }\n                    // 3. 创建新的 AudioContext\n                    console.log(\"创建新的 AudioContext\");\n                    const AudioContextClass = window.AudioContext;\n                    if (AudioContextClass) {\n                        //@ts-ignore\n                        const audioSupport = cc.sys.__audioSupport;\n                        //以下摘自引擎源码的创建方式\n                        if (audioSupport.WEB_AUDIO) {\n                            //@ts-ignore\n                            audioSupport.context = new (window.AudioContext || window.webkitAudioContext || window.mozAudioContext)();\n                            if (audioSupport.DELAY_CREATE_CTX) {\n                                //@ts-ignore\n                                setTimeout(function () { audioSupport.context = new (window.AudioContext || window.webkitAudioContext || window.mozAudioContext)(); }, 0);\n                            }\n                        }\n                        //@ts-ignore\n                        console.log(\"新 AudioContext 创建成功，状态:\", cc.sys.__audioSupport.context.state);\n                    }\n                    resolve(true);\n                } catch (e) {\n                    console.error(\"重建音频系统失败:\", e);\n                    reject(e);\n                }\n            }, 50);\n        });\n    }\n\n    onPlayButtonClick() {\n        console.log(\"播放按钮点击\");\n\n        const audioId = cc.audioEngine.playEffect(this.audioClip, false);\n        cc.audioEngine.setFinishCallback(audioId, () => {\n            console.log(\"音频播放完成，ID:\", audioId);\n        });\n    }\n    \n    private _showTipAudioUI() {\n        const scene = cc.director.getScene();\n        const canvas = scene.getChildByName(\"Canvas\");\n        let tipAudioUI = cc.instantiate(this.tipAudioUI);\n        tipAudioUI.parent = canvas;\n        tipAudioUI.setPosition(0, 0);\n        tipAudioUI.on(cc.Node.EventType.TOUCH_START, () => {\n            this.restorePausedAudios();\n            tipAudioUI.destroy();\n        });\n    }\n\n    onResume() {\n        console.log(\"手动恢复按钮点击\");\n        // this.rebuildAudioSystem();\n\n        this.restorePausedAudios();\n    }\n\n    onReplay() {\n        const id = cc.audioEngine.playEffect(this.audioClip, false);\n        const onFinish = () => {\n            console.log(\"音频播放完成，ID:\", id);\n        }\n        cc.audioEngine.setFinishCallback(id, onFinish);\n        cc.audioEngine.setCurrentTime(id, 2);\n    }\n\n    onDestroy() {\n        cc.game.off(cc.game.EVENT_SHOW, this.handleGameShow, this);\n        cc.game.off(cc.game.EVENT_HIDE, this.handleGameHide, this);\n    }\n}","\nconst { ccclass, property } = cc._decorator;\n\n@ccclass\nexport default class NewClass extends cc.Component {\n\n    private _resumeAttempts = 0;\n    private _maxResumeAttempts = 3;\n    private _resumeTimer = null;\n\n    onLoad() {\n        // 使用捕获阶段监听pageshow事件，确保尽早处理\n        window.addEventListener('pageshow', this.onPageShow.bind(this), true);\n        \n        // 使用自定义的展示事件处理函数\n        cc.game.on(cc.game.EVENT_SHOW, this.onGameShow.bind(this));\n        cc.game.on(cc.game.EVENT_HIDE, this.onGameHide.bind(this));\n    }\n\n    onPageShow(event) {\n        console.log(\"pageshow事件触发\", event.persisted);\n        if (event.persisted && cc.sys.os === cc.sys.OS_IOS) {\n            // 清除之前可能存在的定时器\n            this.clearResumeTimer();\n            \n            // 重置恢复尝试次数\n            this._resumeAttempts = 0;\n            \n            // 立即尝试一次恢复\n            this.onResume();\n            \n            // 设置多次尝试恢复的定时器\n            this.scheduleResumeAttempts();\n        }\n    }\n\n    onGameShow() {\n        console.log(\"Game.EVENT_SHOW\");\n        if (cc.sys.os === cc.sys.OS_IOS) {\n            // 清除之前可能存在的定时器\n            this.clearResumeTimer();\n            \n            // 重置恢复尝试次数\n            this._resumeAttempts = 0;\n            \n            // 立即尝试一次恢复\n            this.onResume();\n            \n            // 设置多次尝试恢复的定时器\n            this.scheduleResumeAttempts();\n        }\n    }\n\n    onGameHide() {\n        console.log(\"Game.EVENT_HIDE\");\n        // 清除恢复定时器\n        this.clearResumeTimer();\n    }\n\n    scheduleResumeAttempts() {\n        // 设置多次尝试，间隔递增\n        this._resumeTimer = setTimeout(() => {\n            this._resumeAttempts++;\n            if (this._resumeAttempts < this._maxResumeAttempts) {\n                console.log(`第${this._resumeAttempts}次尝试恢复AudioContext`);\n                this.onResume();\n                this.scheduleResumeAttempts();\n            }\n        }, 300 * (this._resumeAttempts + 1)); // 300ms, 600ms, 900ms递增间隔\n    }\n\n    clearResumeTimer() {\n        if (this._resumeTimer) {\n            clearTimeout(this._resumeTimer);\n            this._resumeTimer = null;\n        }\n    }\n\n    @property(cc.AudioClip)\n    audioClip: cc.AudioClip = null;\n\n    start() {}\n\n    onDestroy() {\n        // 清除定时器\n        this.clearResumeTimer();\n        \n        // 移除事件监听\n        window.removeEventListener('pageshow', this.onPageShow.bind(this), true);\n        cc.game.off(cc.game.EVENT_SHOW, this.onGameShow, this);\n        cc.game.off(cc.game.EVENT_HIDE, this.onGameHide, this);\n    }\n\n    play() {\n        // 在播放前检查AudioContext状态\n        if (cc.sys.os === cc.sys.OS_IOS) {\n            const globalContext = cc.sys.__audioSupport.context;\n            if (globalContext && \n                (globalContext.state === 'suspended' || globalContext.state === 'interrupted')) {\n                \n                console.log(\"播放前恢复AudioContext\");\n                globalContext.resume().then(() => {\n                    this.doPlay();\n                }).catch(err => {\n                    console.error(\"播放前恢复AudioContext失败:\", err);\n                    // 尝试强制恢复\n                    this.forceResumeAudioContext();\n                    setTimeout(() => this.doPlay(), 100);\n                });\n            } else {\n                this.doPlay();\n            }\n        } else {\n            this.doPlay();\n        }\n    }\n\n    doPlay() {\n        const audioId = cc.audioEngine.playEffect(this.audioClip, false);\n        console.log(\"audioId play:\", audioId);\n        if (audioId) {\n            cc.audioEngine.setVolume(audioId, 1);\n            cc.audioEngine.setEffectsVolume(1);\n            cc.audioEngine.setFinishCallback(audioId, () => {\n                console.log(\"audio play finish\");\n            });\n        } else {\n            console.error(\"音频播放失败，无效的audioId\");\n        }\n    }\n\n    onResume() {\n        const globalContext = cc.sys.__audioSupport.context;\n        if (!globalContext) {\n            console.warn(\"找不到全局AudioContext\");\n            return;\n        }\n        \n        console.log(\"当前AudioContext状态:\", globalContext.state);\n        \n        if (globalContext.state === 'suspended' || globalContext.state === 'interrupted') {\n            console.log(\"恢复全局AudioContext\");\n            \n            // 尝试恢复全局AudioContext\n            globalContext.resume().then(() => {\n                console.log(\"全局AudioContext恢复成功\");\n                \n                // 强制\"唤醒\"音频系统\n                this.forceResumeAudioContext();\n                \n                // 恢复正在播放的音频\n                this.resumePlayingAudio();\n            }).catch(err => {\n                console.error(\"恢复AudioContext失败:\", err);\n                \n                // 尝试使用更激进的方式恢复\n                this.forceResumeAudioContext();\n            });\n        } else {\n            console.log(\"AudioContext状态已正常:\", globalContext.state);\n            \n            // 即使状态看起来正常，也进行一次音频恢复\n            // 有时iOS会报告状态正常但实际上还是无法播放\n            this.resumePlayingAudio();\n        }\n    }\n    \n    forceResumeAudioContext() {\n        try {\n            const globalContext = cc.sys.__audioSupport.context;\n            if (!globalContext) return;\n            \n            // 创建一个短暂的空音频来\"唤醒\"系统\n            const testOsc = globalContext.createOscillator();\n            const testGain = globalContext.createGain();\n            testGain.gain.value = 0.01; // 极小音量但不是0\n            testOsc.connect(testGain);\n            testGain.connect(globalContext.destination);\n            testOsc.start(0);\n            setTimeout(() => {\n                try {\n                    testOsc.stop();\n                    testOsc.disconnect();\n                    testGain.disconnect();\n                } catch (e) {}\n            }, 100); // 短暂播放100ms\n            \n            console.log(\"强制唤醒AudioContext完成\");\n        } catch (e) {\n            console.error(\"强制唤醒AudioContext失败:\", e);\n        }\n    }\n    \n    resumePlayingAudio() {\n        // 遍历所有音频并检查它们的状态\n        const audioIds = Object.keys(cc.audioEngine._id2audio);\n        console.log(\"恢复音频状态检查, 当前音频数:\", audioIds.length);\n        \n        if (audioIds.length === 0) return;\n        \n        // 恢复所有正在播放的音频\n        for (let id of audioIds) {\n            const audio = cc.audioEngine._id2audio[id];\n            if (!audio || !audio._element) continue;\n            \n            const audioState = audio._state;\n            console.log(`音频ID: ${id}, 状态: ${audioState}`);\n            \n            if (audioState === cc.audioEngine.AudioState.PLAYING && \n                (audio._element.paused || \n                (audio._element._currentSource === null && audio._element._context))) {\n                console.log(`恢复播放音频: ${id}`);\n                \n                try {\n                    // 先确保音量正确\n                    const volume = audio.getVolume();\n                    audio.setVolume(volume);\n                    \n                    // 然后恢复播放\n                    audio.resume();\n                } catch (e) {\n                    console.error(`恢复音频${id}失败:`, e);\n                }\n            }\n        }\n    }\n}"],"file":"index.js"}